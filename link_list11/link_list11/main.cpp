/*
 問題2：2ノードの連結とデータ出力
 * 2つのノードを動的確保して連結する
 * data に 10, 20 を入れる
 * head から2つのノードのデータをループなしで出力
 * 順に delete で2ノードを解放する
 
 
 
 
 
 はい、その感覚はとても正しいです。
 `nullptr` を明示的に設定する習慣は、C++プログラミングにおいて非常に大切です。理由をしっかり理解しておくと、ミスを防げます。
 ---

 ### 🔸 なぜ `nullptr` を入れるのか？

 #### ✅ 意味：「次が存在しない」ことを明確に示す

 ```cpp
 head->next->next = nullptr;
 ```

 これは「このノードはリストの最後」という**明示的なサイン**です。

 ---

 ### 🔸 `nullptr` を入れないとどうなる？

 #### ❌ 未初期化ポインタのままだと…

 ```cpp
 head->next->next; // ← ここにゴミアドレスが残ってるかも
 ```

 * 「変なアドレス」をたどってアクセスしようとして
 * **クラッシュ（セグメンテーションフォールト）**
 * あるいは **未定義動作（UB）**

 ---

 ### 🔹 たとえると

 * `nullptr` を入れない → 出口のないトンネルを作るようなもの
 * `nullptr` を入れる → 「ここで終わり」と**看板を立てる**

 ---

 ### 🔸 練習でも「最後は nullptr」を忘れない

 これは**プロでも重要な癖**です。
 特に動的メモリを扱うときは「初期化 or 明示的な終了」を**必ず書く癖**が必要です。

 ---

 ### ✅ 結論（まとめ）

 | 項目               | 説明                   |
 | ---------------- | -------------------- |
 | `nullptr` を入れる理由 | 終端を明示する、安全なアクセスのため   |
 | 入れないと            | ゴミデータ参照、バグ、クラッシュの原因  |
 | 書くタイミング          | ノードを作成した後、「次が無い」時に必ず |

 ---

 **→ 気持ち悪いと感じるあなたは、すでに良いプログラマーの感覚を持っています◎**
 今後も安心・安全なポインタ操作を心がけていきましょう！
 
 
 
  問題2：2ノードの連結とデータ出力
  * 2つのノードを動的確保して連結する
  * data に 10, 20 を入れる
  * head から2つのノードのデータをループなしで出力
  * 順に delete で2ノードを解放する
  

 */



#include <iostream>

struct Node
{
    
    int data;
    Node* next;
};

int main()
{
    Node* head;
    head = nullptr;
    head = new Node;
    head-> data = 10;
    
    head->next = nullptr;
    head->next = new Node;
    head->next-> data= 20;
    
    head->next ->next= nullptr;
    
    /*
    head->next ->next= nullptr;
    head->next ->next = new Node;
    head->next -> next-> data= 2;
    */
    
    std::cout<< head-> data << std::endl;
    std::cout<< head->next->data << std::endl;
    
    delete head->next;
    delete head;
    
   
  
    return 0;
}
