
/*
 🔸 問2：
 出力(1)と出力(2)の結果を答えなさい。
 change() の中で何が起きているかを説明しなさい。


 */
#include <iostream>


void change(int** p)
//*pを指し示すpointer **pをアドレスptrに代入する, *pのアドレスを1つずらす。
//＊pは配列の要素の値を示しているのでこれが１増えると、２００を指し示す。
{
    *p = *p + 1;
}

int main()
{
    int arr[3] = {100, 200, 300};
    int* ptr = arr;

    std::cout << *ptr << std::endl;   // (1) //arr[0]の値

    change(&ptr);

    std::cout << *ptr << std::endl;   // (2) arr[1]

    return 0;
}

/*
 | 部分            | 意味                               |
 | ------------- | -------------------------------- |
 | `*p`          | `ptr` を指す（`p` は `&ptr` なので）      |
 | `*p + 1`      | `ptr + 1`（つまり `arr[1]` を指すようにする） |
 | `*p = *p + 1` | `ptr = ptr + 1;` と同じ意味           |
 
 *p = *p + 1`の基本の読み方：
「ポインタ ptr が指す位置から、1要素分進んだアドレス」
もっと自然な日本語にすると：
「配列の次の要素を指すアドレス」
（たとえば arr[0] を指していたら、arr[1] を指す）
 
 int arr[3] = {100, 200, 300};
 int* ptr = arr;
 | 式            | 意味                 | 指す値   |
 | ------------ | ------------------ | ----- |
 | `ptr`        | `arr[0]` のアドレス     | `100` |
 | `ptr + 1`    | `arr[1]` のアドレス     | `200` |
 | `ptr + 2`    | `arr[2]` のアドレス     | `300` |
 | `*(ptr + 1)` | `arr[1]` の中身（間接参照） | `200` |

 | 式            | 意味            | 読み方例            |
 | ------------ | ------------- | --------------- |
 | `ptr + 1`    | 配列の次の要素のアドレス  | 「ptrの次の要素のアドレス」 |
 | `*(ptr + 1)` | 次の要素の値        | 「ptrの次の要素の中身」   |
 | `&ptr[1]`    | `ptr + 1` と同じ | 「ptrの1番目のアドレス」  |



 */
