//
//  main.cpp

/*
 | 式      | 型                       | 意味          |
 | `arr`  | `int[5]` → ほぼ `int*`に変換 | 先頭要素のポインタ   |
 | `&arr` | `int (*)[5]`            | 配列全体へのポインター |
 
 C++では、**「配列名」=「先頭要素のポインター」**のように自動変換されますが、
 &arr だけは特別で：
 arr → int[5]（配列）
 &arr → int (*)[5]（配列へのポインター）
 
 型が違う
 
 
 
 配列arr（int arr[5]）
    ┌──────────────┐
    │ arr[0] = 10  │ ← &arr[0]
    ├──────────────┤
    │ arr[1] = 20  │ ← &arr[1]
    ├──────────────┤
    │ arr[2] = 30  │ ← &arr[2]
    ├──────────────┤
    │ arr[3] = 40  │ ← &arr[3]
    ├──────────────┤
    │ arr[4] = 50  │ ← &arr[4]
    └──────────────┘

 p → ┌──────────────────────────────┐
      │     &arr (つまり配列全体)     │ → 型：int (*)[5]
      └──────────────────────────────┘

 
 | 式         | 解釈                     | 結果                |
 | --------- | ------------------------ | -------------------- |
 | `p`       | `&arr`（配列全体のポインタ） | アドレス               |
 | `*p`      | `arr`（配列そのもの）       | `int[5]`             |
 | `(*p)[0]` | `arr[0]`                 | `10`                 |
 | `(*p)[1]` | `arr[1]`                 | `20`                 |
 | `p[0]`    | `*p` → `arr` → `&arr[0]` | `&arr[0]`（先頭要素のアドレス） |
 | `*p[0]`   | `*(&arr[0])` → `arr[0]`  | `10`（でも読みづらい）        |

 
 非常に鋭い質問です！

 **`arr` のアドレス（`&arr`）と `arr[0]` のアドレス（`&arr[0]`）は**
 → **数値的には同じです。でも**
 → **意味（型）が違う** ＝ **解釈・使い方が異なる**！

 ## 🔹1. アドレス値は「同じ」

 int arr[5] = {1, 2, 3, 4, 5};

 std::cout << &arr     << std::endl; // 配列全体のアドレス
 std::cout << &arr[0]  << std::endl; // 先頭要素のアドレス
 ```
 この2つの出力は、**同じ数値（同じアドレス値）になります。**
 なぜなら、**配列全体の最初のアドレスは arr\[0] の場所と同じだから**。

 ---

 ## 🔹2. でも型が違う

 | 式         | 型            | 意味           |
 | --------- | ------------ | ------------ |
 | `&arr`    | `int (*)[5]` | 配列全体へのポインタ   |
 | `&arr[0]` | `int*`       | 要素へのポインタ（先頭） |

 この「型」の違いが重要です。

 たとえば：

 ```cpp
 int (*p1)[5] = &arr;     // OK
 int* p2 = &arr[0];       // OK
 int* p3 = &arr;          // ⚠️ NG（警告またはエラーの可能性）
 ```

 → `&arr` は `int (*)[5]` 型なので、`int*` 型に代入できません。

 ---

 ## 🔹3. ポインタ演算の違い

 ```cpp
 int arr[5] = {1, 2, 3, 4, 5};

 int* p1 = arr;        // 要素へのポインタ
 int (*p2)[5] = &arr;  // 配列全体へのポインタ

 p1 + 1 → arr[1] の場所（4バイト分進む）
 p2 + 1 → 次の配列5個分（20バイト分進む）
 ```

 ---

 ## 🔹4. たとえると…

 * `arr`：5部屋のうちの「1号室」の鍵（int\*）
 * `&arr`：5部屋まとめて1つの「団地」の鍵（int (\*)\[5]）
 → **鍵の形は違うけど、1号室の場所は同じ**
 → **でも団地用の鍵で1号室にだけアクセスはできないし、その逆もしかり**

 ---

 ## 🔹5. まとめ

 | 比較項目  | `&arr`      | `&arr[0]` |
 | ----- | ------------- | ----------- |
 | アドレス値 | 同じ        | 同じ     |
 | 型     | `int (*)[5]`  | `int*`      |
 | 意味    | 配列全体へのポインタ    | 先頭要素へのポインタ  |
 | 演算    | `+1` で配列5個分進む | `+1` で1要素進む |

 
 もっと深く知りたい場合は、「関数に `int (*)[5]` を渡す意味」や「2次元配列と `&arr[i]` の違い」なども解説できますよ。見てみますか？

 */


#include <iostream>

int main()
{
    int arr[5] = {1,2,3,4,5};
    int (*p)[5] = &arr; //int (*p)[5] = &arr. &arr は int (*)[5] 型なので、int* 型に代入できない。
    
    std::cout << &arr << std::endl;
    std::cout << (*p)[0] << std::endl;
    std::cout << p[0] << std::endl;
    
    
    
    
    
   
    return 0;
}
