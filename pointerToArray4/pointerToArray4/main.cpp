/*

 decayを起こすと型が変わるはず
 
 | パターン | 仮引数の書き方                    | 実引数の例          | 渡される型（仮引数の型）        | メモ                  |
 | ---- | -------------------------- | ------------------------ | -------------------------- | -------------------- |
 | A    | `void func(int arr[])`     | `int a[5] = {1,2,3,4,5}` | `int*`（ポインタにdecay される）| 配列の先頭アドレスのみ渡される
 | B    | `void func(int (&arr)[5])` | `int a[5] = {1,2,3,4,5}` | `int (&)[5]`（参照。decay しない） | サイズ付き配列として渡る
 | C    | `void func(int* arr)`      | `int a[5] = {1,2,3,4,5}` | `int*`                     | Aと同じ（arr\[]はポインタと同義） |
 | D    | `void func(int (&arr)[N])` | `int a[N] = {...}`       | `int (&)[N]`               | C++のテンプレートでN個の長さを保持可

 
 ✅ 「decay」とは？
 配列を「関数の仮引数」として渡すときに発生する
 配列型は関数の引数として渡すと 自動的にポインタに変換される（decay）。
 int arr[] → int* arrに変わるので、配列のサイズ情報が失われる。
 型の整合性も崩れる

 ✅ &arr（参照）を使うと？
 &arr で参照を使うと decay しないため、元の配列のサイズ情報が保持される。
 ただし、長さが一致しないと呼び出せないので注意。
 
 | 観点          | `int arr[]`  　　　　　　　　| `int (&arr)[N]` |
 | ----------- | ------------------------ 　| --------------- |
 | decay（変形）   | する                     | しない（配列参照）       |
 | sizeof(arr) | ポインタのサイズ（例：8）       | 配列全体のサイズ（例：20）  |
 | 配列長の情報      | 消える                      | 保持される           |
 | 書きやすさ       | ◎（簡易）                    | △（厳密で少し面倒）      |
 | 型安全性        | △（崩れる）                   | ◎（崩れない）         |

 
 
 &arr は「配列全体」へのポインタ？　アドレスを示すものなのになぜポインターになるの?
 とても良い質問です。「`&arr` はアドレスを示すのに、なぜ『ポインタ』になるのか？」
 この疑問は C++ の「**型の意味と文法**」をしっかり理解する鍵です。

 > ✅ `&arr` は「配列全体 `arr` のアドレス」であり、
 > ✅ **その型は `int (*)[5]`**、つまり「**5個のintからなる配列へのポインタ**」です。

 だから「ポインタ」と呼ばれます。

 ---

 int arr[5];  // 配列。型は int[5]
 ```

 ### 🧠 そのアドレスを取るとどうなる？
 &arr;
 これは「arr（int[5]）というオブジェクトのアドレスを取る」という意味。

では型は？
 &arr → 型は int (*)[5]
 * & → アドレス演算子：オブジェクトのアドレスを取る
 * arr の型が int[5]
 * よって &arr の型は int\[5] へのポインタ＝ int (*)[5]

 ---

 ## 📌 ポインタとは何か？

 C++では、「〇〇へのポインタ」＝「〇〇型のオブジェクトのアドレス」を持つ型です。
 * int* は「int へのポインタ」＝ `int` 型の変数のアドレスを持つ
 * int (*)[5]` は「int\[5] へのポインタ」＝ 配列全体（int\[5]）のアドレスを持つ
 → だから &arr はポインタと呼ばれます。

 ---

 ## 🧪 実験してみる
 int arr[5] = {1, 2, 3, 4, 5};
 std::cout << arr     << std::endl; // arr → 先頭要素のアドレス（int* に decay）
 std::cout << &arr    << std::endl; // &arr → 配列全体のアドレス（int (*)[5]）
 std::cout << &arr[0] << std::endl; // 配列の先頭要素のアドレス（int*）
 ✅ `arr` と `&arr[0]` は同じ値になる
 ✅ でも `&arr` は「配列全体」なので違う型、違う意味
 ---
 ## ✅ 最後にまとめ

 | 式         | 意味                  | 型          |
 | --------- | ------------------- | ------------ |
 | `arr`     | 配列の先頭要素のポインタに decay | `int*` |
 | `&arr[0]` | 先頭要素のアドレス      | `int*`       |
 | `&arr`    | 配列全体のアドレス      | `int (*)[5]` |


*/

#include<iostream>

void printArr1(int (*p)[3])
{
    for(int i= 0; i < 3; i++)
    {
        std::cout << *p[i] << std::endl;
    }
    
}

void printArr2(int* arr)
{
    for(int i= 0; i < 3; i++)
    {
        std::cout << arr[i] << std::endl;
    }
    
}


#include <iostream>

int main()
{
    int arr[3] = {1,2,3};
    
    //&arrで渡したら呼び出される関数の引数はint (*p)[3]で固定される
    
    //int (*p)[5] = &arr;
    printArr1(&arr);
    
    
    /*
     
     int (*p)[5] = &arr;　この形で覚えて良い。
     左辺
     int (*p)[5] は「5個のintを持つ配列へのポインタ」を意味します。
     *p が int[5] なので、(*p)[i] は i 番目の要素にアクセスできます。
     
     右辺
     ここで &arr は何かというと：
     arr の型は int[5]（5個のintを持つ配列）
     &arr の型は int (*)[5]（配列全体へのポインタ）
     これが関数の引数 int (*p)[5] にぴったり一致するのです。
     
     */
    
    printArr2(arr);
    
    
    
    
    return 0;
}
