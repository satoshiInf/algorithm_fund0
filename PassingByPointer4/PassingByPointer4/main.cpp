#include <iostream>

int main() {
    int arr[3] = {10, 20, 30};
    int* p = arr;

    std::cout << &arr[1] << std::endl; //20を要素にもつアドレス　：arr[1]のアドレス
    std::cout << p + 1 << std::endl; // pポインター（arrのアドレス)の+1したアドレス：arr[1]のアドレス
    std::cout << &p[1] << std::endl; //pポインターpの＋1先のアドレス：arr[1]のアドレス
    std::cout << &(p + 1) << std::endl; //ポインターpから＋1したアドレスのアドレス
    // &(p + 1) ≡ &(&p[1])
    
    /*
     int arr[3] = {10, 20, 30};
     int* p = arr;  // pはarrの先頭アドレス（仮に0x1000とする）

     
    | 式          | 意味                         | 型       | 仮の値              |
    | ---------- | -------------------------- | ------- | ---------------- |
    | `p`        | 0x1000（10のアドレス）            | `int*`  | 0x1000           |
    | `p + 1`    | 0x1004（20のアドレス）            | `int*`  | 0x1004           |
    | `&(p + 1)` | 「0x1004という値そのものの保管場所のアドレス」 | `int**` | 例：0x7ffcbcd8ab00 |

     */
    

    return 0;
}
/*
 
 p + 1 ≡ p[1]
 
 ✅ ① &arr[1]
 「配列 arr の1番目（20）のアドレス」
 &arr[1] は → arr + 1 と同じ
 🔁 20の場所のアドレスが表示されます
 ✅ ② p + 1
 p は arr の先頭なので、p + 1 は arr[1] のアドレス
 つまりこれも → 20のアドレス
 🔁 ①と同じアドレスが出力されます
 ✅ ③ &p[1]
 p[1] は *(p + 1) のこと
 &p[1] は → p + 1 のアドレス
 つまりこれも → 20のアドレス

 🔁 ①、②と同じアドレス
 ❌ ④ &(p + 1)
 これは一見似ているけど違う！
 p + 1 は「int* 型の値（アドレス）」です
 &(p + 1) は「その値自体のアドレス」＝ int**（ダブルポインタ型）
 📌 つまり：
 p + 1 → 「20のアドレス」
 &(p + 1) → 「その 'アドレス値' が入っている場所のアドレス」← これが謎になりやすい


 
 
 
 
 
 
問1-A：
 上記の4つの出力のうち、意味とアドレスが一致するペアをすべて選びなさい。

 A. &arr[1]
 B. p + 1
 C. &p[1]
 D. &(p + 1)
問1-B：
 &(p + 1) の型は何か？
 a. int*
 b. int**
 c. int
 d. コンパイルエラー
 */
